#!/usr/bin/perl
# -*- tab-width: 4 -*-"
# $Id: genxref,v 1.49 2011/12/27 19:34:22 ajlittoz Exp $

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

use strict;
use lib 'lib';
use Fcntl;
use Getopt::Long;
use IO::Handle;
use File::MMagic;

use LXR::Files;
use LXR::Index;
use LXR::Config;
use LXR::Tagger;
use LXR::Common;

my %option;
GetOptions	(\%option
			, "help!"
			, "url=s"
			, "version=s"
			, "allurls!"
			, "allversions!"
			, "reindexall!"
			, "checkonly!"
			);

if ($option{'help'}) {

	# this may not be the best way to implement this, but at least it's something
	print <<END_HELP;
Usage: genxref [option ...]

The genxref program automatically generates LXR database cross-reference
tokens for a set of URL configuration blocks and source code versions.  These
are both defined in the lxr.conf configuration file.  Each "URL" is a separate
source tree; LXR separates and identifies these by their URL.  Each "version" is
a different version of the source tree being indexed.  See lxr.conf or
lxr.conf.template for configuring URLs and versions.

Valid options are:
  --help             Print a summary of the options.
  --url=URL          Generate tokens for the given URL configuration block.
  --allurls          Generate tokens for all URL configuration blocks.
  --version=VERSION  Generate tokens for the given version of the code.
  --allversions      Generate tokens for all versions of the code (default).
  --reindexall       Purges existing index data
  --checkonly        Verify tools version and stop
  
Report bugs at http://sourceforge.net/projects/lxr/.
END_HELP
	exit 0;
}

# Some ANSI escape sequences to highlight error messages in output
my $CSI = "\x1b[";	# CSI = esc [
my $VTbold = "${CSI}1m";
my $VTnorm = "${CSI}0m";
my $VTred = "${VTbold}${CSI}31m";
my $VTyellow = "${VTbold}${CSI}33m";
my $VTgreen = "${VTbold}${CSI}32m";

my $failure = 0;	# Cumulative failure indicator

printf "Checking Perl version ... %vd ", $^V;
if ($^V gt v5.10.0) {
	print "${VTgreen} OK ${VTnorm}\n";
} else {
	print "${VTred}FAIL${VTnorm}\n";
	$failure = 1;
}

# TODO: implement --allurls
die("Option --allurls not implemented.  Use --url instead.\n")
  if $option{'allurls'};

if ($option{'checkonly'} && !$option{'url'}) {
	print "${VTyellow}No URL specified - Continuing in checking mode${VTnorm}\n";
} else {
	die("${VTred}URL must be specified.${VTnorm} Try \"genxref --help\".\n")
		unless $option{'url'};
}

if ($option{'url'}) {
	$config = new LXR::Config($option{'url'});
}

# Check tools version

my $tool;
my $toolloc;
my $version;

if ($config && $config->{'ectagsbin'}) {
	$tool = $config->{'ectagsbin'};
	$toolloc = `which ctags`;
	$toolloc =~ s/\n$//s;
	if ($tool ne $toolloc) {
		print "${VTyellow}'ectagsbin' not equal to `which ctags`${VTnorm}\n";
		print "If this is a non-system copy, ignore this warning\n";
	}
} else {
	print("${VTyellow}Parameter 'ectagsbin' not defined - trying to find ctags${VTnorm}\n");
	$toolloc = `which ctags`;
	$toolloc =~ s/\n$//s;
	if (!$toolloc) {
		print "${VTred}ctags not found, `which ctags` returned a null string\n";
		print "genxref can't index source-tree without ctags\n";
		print "Find its location or install it and fix 'ectagsbin'\n";
		$failure = 1;
		goto END_TEST_CTAGS;
	}
	$config->{'ectagsbin'} = $toolloc;
	$tool = $toolloc;
	print "'ectagsbin' temporarily adjusted to ${VTyellow}$toolloc${VTnorm}\n";
	print "Manually update lxr.conf for permanent setting\n";
}
print("Checking ctags version ... ");
$version = `$tool --version`;
$version =~ /Exuberant ctags +((\d+\.)*\d+)/i;
print "$1 ";
$version =~ /(\d+)/;
if ($1 < 5) {
	print "${VTred}FAIL${VTnorm}\n";
	die "Exuberant ctags version 5 or above required, found $version\n";
} else {
	print "${VTgreen} OK ${VTnorm}\n";
}
END_TEST_CTAGS:

if ($config && $config->{'glimpsebin'}) {
	$tool = $config->{'glimpsebin'};
	$toolloc = `which glimpse`;
	$toolloc =~ s/\n$//s;
	if ($tool ne $toolloc) {
		print "${VTyellow}'glimpsebin' not equal to `which glimpse`${VTnorm}\n";
		print "If this is a non-system copy, ignore this warning\n";
	}
} else {
	print("${VTyellow}Parameter 'glimpsebin' not defined - trying to find glimpse${VTnorm}\n");
	$toolloc = `which glimpse`;
	$toolloc =~ s/\n$//s;
	if (!$toolloc) {
		print "${VTred}glimpse not found${VTnorm}, `which glimpse` returned a null string\n";
		goto END_TEST_GLIMPSE;
	}
	$config->{'glimpsebin'} = $toolloc;
	$tool = $toolloc;
	print "'glimpsebin' temporarily adjusted to ${VTyellow}$toolloc${VTnorm}\n";
	print "Manually update lxr.conf for permanent setting\n";
}
print("Checking glimpse version ... ");
$version = `$tool -V`;
if ($version eq '') {
	print "?? ";
	print "${VTred}FAIL${VTnorm}";
	$failure = 1
} else {
	$version =~ /.*glimpse .*?((\d+\.)*\d+)/i;
	print "${VTyellow}$1${VTnorm} ";
# 	if ($1 < 5) {
# 		print "${VTred}FAIL${VTnorm}\n";
# 		print "Glimpse version xx or above required, found $version\n";
# } else {
# 	print "${VTgreen} OK ${VTnorm}\n";
}
print "\n";
END_TEST_GLIMPSE:

$version = '';
if ($config && $config->{'glimpseindex'}) {
	$tool = $config->{'glimpseindex'};
	$toolloc = `which glimpseindex`;
	$toolloc =~ s/\n$//s;
	if ($tool ne $toolloc) {
		print "${VTyellow}'glimpseindex' not equal to `which glimpseindex`${VTnorm}\n";
		print "If this is a non-system copy, ignore this warning\n";
	}
} else {
	print("${VTyellow}Parameter 'glimpseindex' not defined - trying to find glimpseindex${VTnorm}\n");
	$toolloc = `which glimpseindex`;
	$toolloc =~ s/\n$//s;
	if (!$toolloc) {
		print "${VTred}glimpseindex not found${VTnorm}, `which glimpseindex` returned a null string\n";
		goto END_TEST_GLIMPSEINDEX;
	}
	$config->{'glimpseindex'} = $toolloc;
	$tool = $toolloc;
	print "'glimpseindex' temporarily adjusted to ${VTyellow}$toolloc${VTnorm}\n";
	print "Manually update lxr.conf for permanent setting\n";
}
print("Checking glimpseindex version ... ");
$version = `$tool -V`;
if ($version eq '') {
	print "?? ";
	print "${VTred}FAIL${VTnorm}";
	$failure = 1
} else {
	$version =~ /.*glimpseindex .*?((\d+\.)*\d+)/i;
	print "${VTyellow}$1${VTnorm} ";
# 	if ($1 < 5) {
# 		print "${VTred}FAIL${VTnorm}\n";
# 		print "Glimpse version xx or above required, found $version\n";
# } else {
# 	print "${VTgreen} OK ${VTnorm}\n";
}
print "\n";
END_TEST_GLIMPSEINDEX:

if ($config && $config->{'swishbin'}) {
	$tool = $config->{'swishbin'};
	$toolloc = `which swhish-e`;
	$toolloc =~ s/\n$//s;
	if ($tool ne $toolloc) {
		print "${VTyellow}'swishbin' not equal to `which swish-e`${VTnorm}\n";
		print "If this is a non-system copy, ignore this warning\n";
	}
} else {
	print("${VTyellow}Parameter 'swishbin' not defined - trying to find swish-e${VTnorm}\n");
	$toolloc = `which swish-e`;
	$toolloc =~ s/\n$//s;
	if (!$toolloc) {
		print "${VTred}swish-e not found${VTnorm}, `which swish-e` returned a null string\n";
		goto END_TEST_SWISHE;
	}
	$config->{'swishbin'} = $toolloc;
	$tool = $toolloc;
	print "'swishbin' temporarily adjusted to ${VTyellow}$toolloc${VTnorm}\n";
	print "Manually update lxr.conf for permanent setting\n";
}
print("Checking swishe version ... ");
$version = `$tool -V`;
if ($version eq '') {
	print "?? ";
	print "${VTred}FAIL${VTnorm}";
	$failure = 1
} else {
	$version =~ /.*swish-e .*?((\d+\.)*\d+)/i;
	print("${VTyellow}$1${VTnorm}");
# 	if ($1 < 5) {
# 		print "${VTred}FAIL${VTnorm}\n";
# 		die "Glimpse version xx or above required, found $version\n";
# } else {
# 	print "${VTgreen} OK ${VTnorm}\n";
}
print "\n";
END_TEST_SWISHE:

die("${VTred}No matching configuration${VTnorm}") unless $config->{'sourceroot'};

$files = new LXR::Files($config->sourceroot, $config->sourceparams);
die "${VTred}Can't create file access object ${VTnorm}" . $config->sourceroot
  if !defined($files);
$index = new LXR::Index($config->dbname, O_RDWR | O_CREAT);
die "${VTred}Can't create Index ${VTnorm}" . $config->dbname if !defined($index);

# End of general checks
if ($failure) {
	die "${VTred}Aborting due to previous errors${VTnorm}";
}
if ($option{'checkonly'}) {
	print "${VTyellow}genxref stopped without indexing by --checkonly option${VTnorm}\n";
	exit;
}

our $filetype = new File::MMagic(-f 'lib/magic.mime'? ('lib/magic.mime') : ());
our %binaryfiles;

my @versions;

if ($option{'allversions'} || !$option{'version'}) {
	@versions = $config->varrange('v');
	die
	  "${VTred}Option --allversions cannot be used because no versions found automatically.${VTnorm}  Use --version=VERSION or fix lxr.conf.\n"
	  if scalar @versions <= 0;
} else {
	@versions = $option{'version'};
}

foreach my $version (@versions) {
	$index->purge($version) if $option{'reindexall'};
	gensearch($version);
	genindex('/', $version);
	genrefs('/', $version);
	$index->commit;
}

$index->DESTROY();

sub genindex {
	my ($pathname, $releaseid) = @_;

	print(STDERR "*** $pathname $releaseid \n");

	if ($pathname =~ m|/$|) {
		map { genindex($pathname . $_, $releaseid) } $files->getdir($pathname, $releaseid);
	} else {
		&LXR::Tagger::processfile($pathname, $releaseid, $config, $files, $index)
		  unless exists $binaryfiles{$pathname};
		$index->commit;
	}
}

sub genrefs {
	my ($pathname, $releaseid) = @_;

	print(STDERR "### $pathname $releaseid \n");

	if ($pathname =~ m|/$|) {
		map { genrefs($pathname . $_, $releaseid) } $files->getdir($pathname, $releaseid);
	} else {
		&LXR::Tagger::processrefs($pathname, $releaseid, $config, $files, $index)
		  unless exists $binaryfiles{$pathname};
		$index->commit;
	}
}

sub feedswish {
	my ($pathname, $releaseid, $swish, $filelist) = @_;

	print(STDERR "&&& $pathname $releaseid \n");

	if ($pathname =~ m|/$|) {
		map { feedswish($pathname . $_, $releaseid, $swish, $filelist) }
		  $files->getdir($pathname, $releaseid);
	} else {
		print $filelist "$pathname\n";
		my $fh = $files->getfilehandle($pathname, $releaseid);
		if ($files->getfilesize($pathname, $releaseid) > 0
			&& $filetype->checktype_filehandle($fh) =~ m%(text|message)/%)
		{
			my $contents = $files->getfile($pathname, $releaseid);
			$swish->print(
				"Path-Name: $pathname\n",
				"Content-Length: " . length($contents) . "\n",
				"Document-Type: TXT\n",
				"\n", $contents
			);
		} else {
			$binaryfiles{$pathname} = 1;
		}
		close($fh);
	}
}

sub gensearch {
	my ($releaseid) = @_;
	my $string;

	if ($config->glimpsedir and $config->glimpseindex) {

		$string = $config->glimpsedir . "/" . $releaseid;
		mkdir $string;
		system("chmod 755 $string");   # TODO - fix Unix specific call?
		my $glimpse = new IO::Handle;
		my $pid = open($glimpse, "|-");
		if ($pid == 0) {
			exec($config->glimpseindex, "-n", "-o", "-H",
				$config->glimpsedir . "/$releaseid",
				$config->sourceroot . "/" . $releaseid
			);
			print(STDERR "Couldn't exec " . $config->glimpseindex . ": $!\n");
			kill(9, $$);
		}
		$glimpse->close();

		# Need to chmod the glimpse files so everybody can read them.
		$string = $config->glimpsedir . "/" . $releaseid . "/.glimpse\*";
		system("chmod 644 $string");
	}

	if ($config->swishdir and $config->swishbin) {
		my $swish = new IO::Handle;
		die ${VTred} . $config->swishdir . " does not exist${VTnorm}"
			unless -d $config->swishdir;
		my $filelist = new IO::File $config->swishdir . "/$releaseid.filenames", "w"
		  or die "${VTred}can't open $releaseid.filenames for writing${VTnorm}";

		# execute swish, as a pipe we can write to

		open($swish,
			    "| "
			  . $config->swishbin
			  . " -S prog -i stdin -v 1 -c swish-e.conf -f "
			  . $config->swishdir . "/"
			  . $releaseid
			  . ".index")
		  or die ${VTred} . "Couldn't exec " . $config->swishbin . ":${VTnorm $!}\n";

		feedswish("/", $releaseid, $swish, $filelist);

		$swish->close();
		$filelist->close();
	}
}
