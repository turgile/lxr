#!/usr/bin/perl
# -*- tab-width: 4 -*-"
# $Id: genxref,v 1.58 2012/04/17 08:10:46 ajlittoz Exp $

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

use strict;
use lib 'lib';
use Fcntl;
use Getopt::Long;
use IO::Handle;
use File::MMagic;

use LXR::Files;
use LXR::Index;
use LXR::Config;
use LXR::Tagger;
use LXR::Common;

my %option;
GetOptions	(\%option
			, "help!"
			, "url=s"
			, "version=s"
			, "allurls!"
			, "allversions:s"
			, "reindexall!"
			, "checkonly!"
			);

if ($option{'help'}) {

	# this may not be the best way to implement this, but at least it's something
	print <<END_HELP;
Usage: genxref [option ...]

The genxref program automatically generates LXR database cross-reference
tokens for a set of URL configuration blocks and source code versions.  These
are both defined in the lxr.conf configuration file.  Each "URL" is a separate
source tree; LXR separates and identifies these by their URL.  Each "version" is
a different version of the source tree being indexed.  See lxr.conf or
lxr.conf.template for configuring URLs and versions.

Valid options are:
  --help             Print a summary of the options.
  --url=URL          Generate tokens for the given URL configuration block.
  --allurls          Generate tokens for all URL configuration blocks.
  --version=VERSION  Generate tokens for the given version of the code.
  --allversions      Generate tokens for all versions of the code (default).
  --reindexall       Purges existing index data
  --checkonly        Verify tools version and stop
  
Report bugs at http://sourceforge.net/projects/lxr/.
END_HELP
	exit 0;
}

# Some ANSI escape sequences to highlight error messages in output
my $CSI = "\x1b[";	# CSI = esc [
my $VTbold = "${CSI}1m";
my $VTnorm = "${CSI}0m";
my $VTred = "${VTbold}${CSI}31m";
my $VTyellow = "${VTbold}${CSI}33m";
my $VTgreen = "${VTbold}${CSI}32m";

my $failure = 0;	# Cumulative failure indicator

# TODO: implement --allurls
die("Option --allurls not implemented.  Use --url instead.\n")
  if $option{'allurls'};

if ($option{'checkonly'} && !$option{'url'}) {
	print "${VTyellow}No URL specified - Continuing in checking mode${VTnorm}\n";
} else {
	die("${VTred}URL must be specified.${VTnorm} Try \"genxref --help\".\n")
		unless $option{'url'};
}

if ($option{'url'}) {
	$config = LXR::Config->new($option{'url'});
}


#######################################
###
###               Part 1
###
###  Check environment
###
###

printf "Checking Perl version ... %vd ", $^V;
if ($^V ge v5.8.0) {
	print "${VTgreen} OK ${VTnorm}\n";
} else {
	print "${VTred}FAIL${VTnorm}\n";
	$failure = 1;
}

# Check tools version

my $tool;
my $toolloc;
my $version;
my $foundglimpse;
my $foundswishe;

if ($config && $config->{'ectagsbin'}) {
	$tool = $config->{'ectagsbin'};
	$toolloc = `which ctags 2>/dev/null`;
	$toolloc =~ s/\n$//s;
	if ($tool ne $toolloc) {
		print "${VTyellow}'ectagsbin' not equal to `which ctags`${VTnorm}\n";
		print "If this is a non-system copy, ignore this warning\n";
	}
} else {
	print("${VTyellow}Parameter 'ectagsbin' not defined - trying to find ctags${VTnorm}\n");
	$toolloc = `which ctags 2>/dev/null`;
	$toolloc =~ s/\n$//s;
	if (!$toolloc) {
		print "${VTred}ctags not found, `which ctags` returned a null string\n";
		print "genxref can't index source-tree without ctags\n";
		print "Find its location or install it and fix 'ectagsbin'\n";
		$failure = 1;
		goto END_TEST_CTAGS;
	}
	$config->{'ectagsbin'} = $toolloc;
	$tool = $toolloc;
	print "'ectagsbin' temporarily adjusted to ${VTyellow}$toolloc${VTnorm}\n";
	print "Manually update lxr.conf for permanent setting\n";
}
print("Checking ctags version ... ");
$version = `$tool --version`;
$version =~ /Exuberant ctags +((\d+\.)*\d+)/i;
$version = $1;
print "$1 ";
$version =~ /(\d+)/;
if (!defined($version) || $1 < 5) {
	print "${VTred}FAIL${VTnorm}\n";
	print "Exuberant ctags version 5 or above required, found $version\n";
	$failure = 1; 
} else {
	print "${VTgreen} OK ${VTnorm}\n";
}
END_TEST_CTAGS:

if ($config && $config->{'glimpsebin'}) {
	$tool = $config->{'glimpsebin'};
	$toolloc = `which glimpse 2>/dev/null`;
	$toolloc =~ s/\n$//s;
	if ($tool ne $toolloc) {
		print "${VTyellow}'glimpsebin' not equal to `which glimpse`${VTnorm}\n";
		print "If this is a non-system copy, ignore this warning\n";
	}
} else {
	print("${VTyellow}Parameter 'glimpsebin' not defined - trying to find glimpse${VTnorm}\n");
	$toolloc = `which glimpse 2>/dev/null`;
	$toolloc =~ s/\n$//s;
	if (!$toolloc) {
		print "${VTred}glimpse not found${VTnorm}, `which glimpse` returned a null string\n";
		goto END_TEST_GLIMPSE;
	}
	$foundglimpse = $toolloc;
	$tool = $toolloc;
	print "'glimpsebin' temporarily adjusted to ${VTyellow}$toolloc${VTnorm}\n";
	print "Manually update lxr.conf for permanent setting\n";
}
print("Checking glimpse version ... ");
$version = `$tool -V`;
if ($version eq '') {
	print "?? ";
	print "${VTred}FAIL${VTnorm}";
	$failure = 1
} else {
	$version =~ /.*glimpse .*?((\d+\.)*\d+)/i;
	print "${VTyellow}$1${VTnorm} ";
# 	if ($1 < 5) {
# 		print "${VTred}FAIL${VTnorm}\n";
# 		print "Glimpse version xx or above required, found $version\n";
# } else {
# 	print "${VTgreen} OK ${VTnorm}\n";
}
print "\n";
END_TEST_GLIMPSE:

$version = '';
if ($config && $config->{'glimpseindex'}) {
	$tool = $config->{'glimpseindex'};
	$toolloc = `which glimpseindex 2>/dev/null`;
	$toolloc =~ s/\n$//s;
	if ($tool ne $toolloc) {
		print "${VTyellow}'glimpseindex' not equal to `which glimpseindex`${VTnorm}\n";
		print "If this is a non-system copy, ignore this warning\n";
	}
} else {
	print("${VTyellow}Parameter 'glimpseindex' not defined - trying to find glimpseindex${VTnorm}\n");
	$toolloc = `which glimpseindex 2>/dev/null`;
	$toolloc =~ s/\n$//s;
	if (!$toolloc) {
		print "${VTred}glimpseindex not found${VTnorm}, `which glimpseindex` returned a null string\n";
		goto END_TEST_GLIMPSEINDEX;
	}
	$config->{'glimpseindex'} = $toolloc;
	$tool = $toolloc;
	print "'glimpseindex' temporarily adjusted to ${VTyellow}$toolloc${VTnorm}\n";
	print "Manually update lxr.conf for permanent setting\n";
}
print("Checking glimpseindex version ... ");
$version = `$tool -V`;
if ($version eq '') {
	print "?? ";
	print "${VTred}FAIL${VTnorm}";
	$failure = 1
} else {
	$version =~ /.*glimpseindex .*?((\d+\.)*\d+)/i;
	print "${VTyellow}$1${VTnorm} ";
# 	if ($1 < 5) {
# 		print "${VTred}FAIL${VTnorm}\n";
# 		print "Glimpse version xx or above required, found $version\n";
# } else {
# 	print "${VTgreen} OK ${VTnorm}\n";
}
print "\n";
END_TEST_GLIMPSEINDEX:

if ($config && $config->{'swishbin'}) {
	$tool = $config->{'swishbin'};
	$toolloc = `which swhish-e 2>/dev/null`;
	$toolloc =~ s/\n$//s;
	if ($tool ne $toolloc) {
		print "${VTyellow}'swishbin' not equal to `which swish-e`${VTnorm}\n";
		print "If this is a non-system copy, ignore this warning\n";
	}
} else {
	print("${VTyellow}Parameter 'swishbin' not defined - trying to find swish-e${VTnorm}\n");
	$toolloc = `which swish-e 2>/dev/null`;
	$toolloc =~ s/\n$//s;
	if (!$toolloc) {
		print "${VTred}swish-e not found${VTnorm}, `which swish-e` returned a null string\n";
		goto END_TEST_SWISHE;
	}
	$foundswishe = $toolloc;
	$tool = $toolloc;
	print "'swishbin' temporarily adjusted to ${VTyellow}$toolloc${VTnorm}\n";
	print "Manually update lxr.conf for permanent setting\n";
}
print("Checking swishe version ... ");
$version = `$tool -V`;
if ($version eq '') {
	print "?? ";
	print "${VTred}FAIL${VTnorm}";
	$failure = 1
} else {
	$version =~ /.*swish-e .*?((\d+\.)*\d+)/i;
	print("${VTyellow}$1${VTnorm}");
# 	if ($1 < 5) {
# 		print "${VTred}FAIL${VTnorm}\n";
# 		die "Glimpse version xx or above required, found $version\n";
# } else {
# 	print "${VTgreen} OK ${VTnorm}\n";
}
print "\n";
END_TEST_SWISHE:

die("${VTred}No matching configuration${VTnorm}") unless exists($config->{'sourceroot'});

if ($config && $config->{'glimpsebin'} && $config->{'swishbin'}) {
	print "${VTred}Both 'glimpsebin' and 'swishbin' defined${VTnorm}\n";
	print "Choose one of them by commenting the other in lxr.conf\n";
	$failure = 1;
}

if ($config && !$config->{'glimpsebin'} && !$config->{'swishbin'}) {
	print "${VTyellow}Neither 'glimpsebin' nor 'swishbin' defined${VTnorm}\n";
	if ($foundglimpse) {
		$config->{'glimpsebin'} = $foundglimpse;
		print "Using existing ${VTyellow}glimpse${VTnorm}\n";
		print "If you prefer swish-e, configure lxr.conf\n";
	} elsif ($foundswishe){
		$config->{'swishbin'} = $foundglimpse;
		print "Using existing ${VTyellow}swish-e${VTnorm}\n";
		print "If you prefer glimpse, configure lxr.conf\n";
	} else {
		print "${VTred}None found in the system - Can't run${VTnorm}\n";
		$failure = 1;
	}
}

if (!exists($config->{'sourceroot'})) {
	print "${VTred}No 'sourceroot' - Can't run${VTnorm}\n";
	$failure = 1; 
}

if (!exists($config->{'variables'}{'v'})) {
	print "${VTred}Variable 'v' needed to define versions - Can't run${VTnorm}\n";
	$failure = 1; 
}

$files = LXR::Files->new($config->sourceroot, $config->sourceparams);
die "${VTred}Can't create file access object ${VTnorm}" . $config->sourceroot
  if !defined($files);
$index = LXR::Index->new($config->dbname, O_RDWR | O_CREAT);
die "${VTred}Can't create Index ${VTnorm}" . $config->dbname if !defined($index);

# End of general checks
if ($failure) {
	die "${VTred}Aborting due to previous errors${VTnorm}";
}
if ($option{'checkonly'}) {
	print "${VTyellow}genxref stopped without indexing by --checkonly option${VTnorm}\n";
	exit;
}


#######################################
###
###               Part 2
###
###  Index source tree(s)
###
###

our $filetype = File::MMagic->new(-f 'lib/magic.mime'? ('lib/magic.mime') : ());
our %binaryfiles;

my @versions;

if (exists($option{'allversions'}) || !$option{'version'}) {
	if	( exists($option{'allversions'})
		&& $option{'allversions'} ne "noauto"
		&& $files->isa("LXR::Files::CVS")
		&& ref($config->{'variables'}{'v'}{'range'}) eq "CODE"
		) {
		print "Using automatic CVS version enumeration\n";
	} else {
		@versions = $config->varrange('v');
		die
		"${VTred}Option --allversions cannot be used because no versions found automatically.${VTnorm}  Use --version=VERSION or fix lxr.conf.\n"
		if scalar @versions <= 0;
	}
} else {
	@versions = $option{'version'};
}

	my %versionset;		# cumulative version set
if ($files->isa("LXR::Files::CVS") && scalar(@versions)<=0) {
	$index->purgeall;
	$$LXR::Common::HTTP{'param'}{'_showattic'} = 1;
	genindex('/', 'head');
	genrefs('/', 'head');
	$index->commit;
	if ( exists($option{'allversions'})
		&& $option{'allversions'} ne "noauto"
		) {
		dump_versionset("CVS", \%versionset);
	}
}

foreach my $version (@versions) {
	$index->purge($version) if $option{'reindexall'};
	if ($files->isa("LXR::Files::Plain")) {
		gensearch($version);
	} else {
		print "${VTyellow}Free-text setup suppressed for VCS storage${VTnorm}\n";
	}
	genindex('/', $version);
	genrefs('/', $version);
	$index->commit;
}

$index->DESTROY();


#######################################
###
###               Annex
###
###  Support routines
###
###

sub genindex {
	my ($pathname, $releaseid) = @_;

	print(STDERR "*** $pathname $releaseid \n");

	if ($pathname =~ m|/$|) {
		map { genindex($pathname . $_, $releaseid) } $files->getdir($pathname, $releaseid);
	} elsif (!exists  $binaryfiles{$pathname}) {
		if	( $files->isa("LXR::Files::CVS")
			&& exists($option{'allversions'})
			&& $option{'allversions'} ne "noauto"
			) {
		# Some 'Files' objects need this variable properly set to
		# determine the possible versions for a file,
		# in particular to return correct values for varrange sub.
			$LXR::Common::pathname = $pathname;
			my @versions = $config->varrange('v');
			foreach my $releaseid (@versions) {
				$versionset{$releaseid} = '';	# remember this version
				&LXR::Tagger::processfile($pathname, $releaseid, $config, $files, $index);
			}
		} else {
			&LXR::Tagger::processfile($pathname, $releaseid, $config, $files, $index);
#			unless exists $binaryfiles{$pathname};
		}
		$index->commit;
	}
}

sub genrefs {
	my ($pathname, $releaseid) = @_;

	print(STDERR "### $pathname $releaseid \n");

	if ($pathname =~ m|/$|) {
		map { genrefs($pathname . $_, $releaseid) } $files->getdir($pathname, $releaseid);
	} elsif (!exists  $binaryfiles{$pathname}) {
		if	( $files->isa("LXR::Files::CVS")
			&& exists($option{'allversions'})
			&& $option{'allversions'} ne "noauto"
			) {
		# Some 'Files' objects need this variable properly set to
		# determine the possible versions for a file,
		# in particular to return correct values for varrange sub.
			$LXR::Common::pathname = $pathname;
			my @versions = $config->varrange('v');
			foreach my $releaseid (@versions) {
				&LXR::Tagger::processfile($pathname, $releaseid, $config, $files, $index);
			}
		} else {
		&LXR::Tagger::processrefs($pathname, $releaseid, $config, $files, $index)
#			unless exists $binaryfiles{$pathname};
		}
		$index->commit;
	}
}

sub feedswish {
	my ($pathname, $releaseid, $swish, $filelist) = @_;

	print(STDERR "&&& $pathname $releaseid \n");

	if ($pathname =~ m|/$|) {
		map { feedswish($pathname . $_, $releaseid, $swish, $filelist) }
		  $files->getdir($pathname, $releaseid);
	} else {
		print $filelist "$pathname\n";
		my $fh = $files->getfilehandle($pathname, $releaseid);
		if ($files->getfilesize($pathname, $releaseid) > 0
			&& $filetype->checktype_filehandle($fh) =~ m%(text|message)/%)
		{
			my $contents = $files->getfile($pathname, $releaseid);
			$swish->print(
				"Path-Name: $pathname\n",
				"Content-Length: " . length($contents) . "\n",
				"Document-Type: TXT\n",
				"\n", $contents
			);
		} else {
			$binaryfiles{$pathname} = 1;
		}
		close($fh);
	}
}

sub gensearch {
	my ($releaseid) = @_;
	my $string;

	if ($config->glimpsedir and $config->glimpseindex) {

		$string = $config->glimpsedir . "/" . $releaseid;
		mkdir $string;
		system("chmod 755 $string");   # TODO - fix Unix specific call?
		my $glimpse = IO::Handle->new();
		my $pid = open($glimpse, "|-");
		if ($pid == 0) {
			exec($config->glimpseindex, "-n", "-o", "-H",
				$config->glimpsedir . "/$releaseid",
				$config->sourceroot . "/" . $releaseid
			);
			print(STDERR "Couldn't exec " . $config->glimpseindex . ": $!\n");
			kill(9, $$);
		}
		$glimpse->close();

		# Need to chmod the glimpse files so everybody can read them.
		$string = $config->glimpsedir . "/" . $releaseid . "/.glimpse\*";
		system("chmod 644 $string");
	}

	if ($config->swishdir and $config->swishbin) {
		my $swish = IO::Handle->new();
		die ${VTred} . $config->swishdir . " does not exist${VTnorm}"
			unless -d $config->swishdir;
		my $filelist = IO::File->new($config->swishdir . "/$releaseid.filenames", "w")
		  or die "${VTred}can't open $releaseid.filenames for writing${VTnorm}";

		# execute swish, as a pipe we can write to

		open($swish,
			    "| "
			  . $config->swishbin
			  . " -S prog -i stdin -v 1 -c ".$config->{'swishconf'}
			  . "-f ".$config->swishdir."/".$releaseid.".index"
			)
		  or die ${VTred} . "Couldn't exec " . $config->swishbin . ":${VTnorm $!}\n";

		feedswish("/", $releaseid, $swish, $filelist);

		$swish->close();
		$filelist->close();
	}
}

sub dump_versionset {
	my ($prefix, $versionset) = @_;
	my $vfh;

	my $virtroot = $config->{'virtroot'};
	$virtroot =~ s|([^-a-zA-Z0-9.\@_])|sprintf("%%%02X", ord($1))|ge;
	my $versionfile = "lxrconf.d/$prefix$virtroot";
	if (!open($vfh, ">", $versionfile)) {
		print "${VTyellow}Can't open : version set not saved${VTnorm}\n";
		return;
	}
	my $count = 0;
	foreach my $version (sort keys %$versionset) {
		$count++;
		print $vfh $version, "\n";
	}
	close($vfh);
	print "=== $count versions written to ${VTyellow}$versionfile${VTnorm}\n";
}
