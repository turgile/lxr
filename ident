#!/usr/bin/perl -T
# $Id: ident,v 1.35 2012/11/14 11:28:12 ajlittoz Exp $
#
# ident --	Look up identifiers
#
#	Arne Georg Gleditsch <argggh@ifi.uio.no>
#	Per Kristian Gjermshus <pergj@ifi.uio.no>
#
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
######################################################################

$CVSID = '$Id: ident,v 1.35 2012/11/14 11:28:12 ajlittoz Exp $ ';

use strict;
use lib do { $0 =~ m{(.*)/} ? "$1/lib" : "lib" }; # if LXR modules are in ./lib

=head1 indent script

This script manages the HTTP requests for identifier search.

=cut

use LXR::Common;
use LXR::Template;
use Local;

#
# Global variables
#
our $defonly = undef;
my $reference_hits;
my $declare_hits;
my $file_hits;
my $bad_refs;


=head2 C<varinputs ()>

Function C<varinputs> is a "$variable" substitution function.
It returns a string which is a concatenation of tags

C<<E<lt>input type="hidden" name=">>I<variable_name>C<" value=">I<variable_value>C<<"E<gt> >>

one for each variable defined in configuration parameter C<'variables'>.

This is how the current state is forwarded to the next HTTP request..

=cut

sub varinputs {
	my $ret = '';
	foreach ($config->allvariables) {
		if ($config->variable($_) ne $config->vardefault($_)) {
			$ret .= "<input type=\"hidden\" name=\"$_\" value=\"" . $config->variable($_) . "\">\n";
		}
	}
	return $ret;
}


=head2 C<countfiles ($refs)>

Function C<countfiles> returns the number of files for the references.

=over

=item 1 C<$refs>

a I<reference> to an array containing the references

=back

The result can be used to display a short informative message.

=cut

sub countfiles {
	my $refs = shift;

	$file_hits = 0;
	my $last_file;
	foreach my $ref (@$refs) {
		my ($file, $line, $type, $rel) = @$ref;
		$file_hits++ if $file ne $last_file;
		$last_file = $file;
	}
}


=head2 C<checkvalidref ($file)>

Function C<checkvalidref> is a "$variable" substitution function.
It returns CSS class name C<identinvalid>
if the file timestamp is incorrect,
meaning the file has been modified after I<genxref> indexing.
Otherwise, it returns an empty string.

=over

=item 1 C<$file>

a I<string> containing the filename to check

=back

Bad referenced file counter is updated to note the existence of
possible trouble.

=cut

sub checkvalidref {
	my ($file) = @_;

	if (	!$index->filetimestamp
				( $file
				, $files->filerev($file, $releaseid)
				)
	# Strictly speaking, call to parseable() is pointless since
	# identifier search requests information from the database
	# only. The file has thus been parsed and parseable() will
	# always return true.
	# However, the line is left here in case some evolution would
	# need it
	#	&&	LXR::Lang::parseable($file)
		) {
		$bad_refs++; 'identinvalid'
	} else {''}
}


=head2 C<expandwarning ($templ)>

Function C<expandwarning> is a "$function" substitution function.
It returns its argument if bad referenced file counter is not zero.
Otherwise, it returns an empty string.

=over

=item 1 C<$templ>

a I<string> containing the template (i.e. argument)

=back

The block for this marker should contain some warning message for
inaccurate cross-references.

=cut

sub expandwarning {
	my ($templ) = @_;

	if ($bad_refs) {
		return expandtemplate($templ)
	} else {
		''
	}
}


=head2 C<refsexpand ($templ, $refs)>

Function C<refsexpand> is a "$function" substitution function.
It returns an HTML string which is the concatenation of its
expanded argument applied to every reference in array
C<$refs>.

=over

=item 1 C<$templ>

a I<string> containing the template (i.e. argument)

=item 1 C<$refs>

a I<reference> to an array containing the usages

=back

The block may use one of two variants for the usages. The variant
is detected from C<$lines> marker use in the template.
Processing is then dispatched on the "one ref per line" (no
C<$lines> marker) or "many refs per line" (C<$lines> marker used)
processing.

This basic expansion function is used both for definitions and uses.
The difference is driven by the block content.

B<CAVEAT:>

=over

I<The element of the references array is a list.
This list does not contain the same number of items for
definitions and usages. In case of modification (notably
the database transactions), take care to keep the file name
and the line number as the first two items in the lists.
Correct operation relies on this constraint.>

=back

=cut

sub refsexpand {
	my ($templ, $refs) = @_;
	my $ret   = '';
	my $last_file;

	countfiles ($refs);
	# Select usage layout on the presence of a specific marker
	if ($templ =~ m/\$lines\b/) {
	# We are in "many refs per line" layout
		my @lines;
		$last_file = @$refs[0];
		($last_file) = @$last_file;
		my $i = 0;
		foreach my $ref (@$refs) {
			my ($file, $line, $type, $rel) = @$ref;
			if ($last_file eq $file) {
				push @lines, $line;
			}
LAST_EXPAND:
			++$i;
			if	( $last_file ne $file
				|| $i >= scalar (@$refs)
				) {
				$ret .= expandtemplate
						( $templ
						,	( 'file'	=>
					sub { fileref("$last_file", "identfile", $last_file) }
							, 'fileonce'=>
					sub { return fileref("$last_file", "identfile", $last_file) }
							, 'lines'	=> sub {
								join	( ' '
										, map { fileref( "$_", "identline", $last_file, $_)
											} @lines
										) }
							, 'type'	=> sub { $type }
							, 'rel'		=>
					sub { return idref("$rel", "identrel", $rel) }
							, 'fileref'	=> sub {
								fileref("$last_file, line $line", "identline", $last_file, $line);
											}
						, 'refinvalid'	=> sub { checkvalidref($last_file) }
							)
						);
				@lines = ($line);
				if	(	$i == scalar (@$refs)
					&&	$last_file ne $file
					) {
					$last_file = $file;
					goto LAST_EXPAND;
				}
			}
		$last_file = $file;
		}
	} else {
	# We are in "one ref per line" layout
		foreach my $ref (@$refs) {
			my ($file, $line, $type, $rel) = @$ref;
			my $fileonce = $file if $last_file ne $file;
			$ret .= expandtemplate
					( $templ
					,	( 'file'	=>
				sub { fileref("$file", "identfile", $file) }
						, 'fileonce'=>
				sub { if ($fileonce) { return fileref("$fileonce", "identfile", $file) } }
						, 'line'	=>
				sub { return fileref( "$line", "identline", $file, $line) }
						, 'type'	=> sub { $type }
						, 'rel'		=>
				sub { return idref("$rel", "identrel", $rel) }
						, 'fileref'	=> sub {
							fileref("$file, line $line", "identline", $file, $line);
										}
						, 'refinvalid'	=> sub { checkvalidref($file) }
						)
					);
			$last_file = $file;
		}
	}
	return $ret;
}


=head2 C<defsexpand ($templ)>

Function C<defsexpand> is a "$function" substitution function.
It returns an HTML string which is the concatenation of its
expanded argument applied to every declaration.

=over

=item 1 C<$templ>

a I<string> containing the template (i.e. argument)

=back

The function queries the database for definitions, then hands over
definition layout to C<refsexpand>.

=cut

sub defsexpand {
	my $templ = shift;
	my $ret;

	my @defs = $index->symdeclarations($identifier, $releaseid);
	return '' if (scalar(@defs) == 0);

	countfiles (\@defs);
	$bad_refs = 0;	# Reset "inaccurate xref" indicator
	my $last_file;
	$ret = expandtemplate
			( $templ
			,	( 'refs'	=> sub { refsexpand (@_, \@defs) }
				, 'occurs'	=> sub { scalar(@defs) }
				, 'filehits'=> sub { $file_hits }
				, 'indexwarning' => sub { expandwarning(@_) }
				)
			);
	return $ret;
}


=head2 C<usessexpand ($templ)>

Function C<usessexpand> is a "$function" substitution function.
It returns an HTML string which is the concatenation of its
expanded argument applied to every usage.

=over

=item 1 C<$templ>

a I<string> containing the template (i.e. argument)

=back

The function queries the database for usages, then hands over
definition layout to C<refsexpand>.

=cut

sub usesexpand {
	my $templ = shift;
	my $ret   = '';

	return '' if $defonly;
	my @uses = $index->symreferences($identifier, $releaseid);
	return '' if (scalar(@uses) == 0);

	countfiles (\@uses);
	$bad_refs = 0;	# Reset "inaccurate xref" indicator
	my $last_file;
	$ret = expandtemplate
			( $templ
			,	( 'refs'	=> sub { refsexpand (@_, \@uses) }
				, 'occurs'	=> sub { scalar(@uses) }
				, 'filehits'=> sub { $file_hits }
				, 'indexwarning' => sub { expandwarning(@_) }
				)
			);
	return $ret;
}


=head2 C<printident ()>

Sub C<printident> is the main driver for identifier search.

=cut

sub printident {
	my $templ;
	my $errorsig = "<!-- ! -->";

	$templ = gettemplate	( 'htmlident'
							, $errorsig
							, "<h2 class\"error\">Identifier search not available without 'htmlident' template</h2>\n"
							);
		if ($templ =~ m/^$errorsig/) {
		die "'htmlident' template not configured";
	}

	print(
		expandtemplate
			( $templ
			,	( 'variables'		=> \&varinputs
				, 'identifier'		=> sub { $_ = $identifier; s/</&lt;/g; s/>/&gt;/g; return $_; }
				, 'identifier_escaped'=> sub { $_ = $identifier; s/\"/&quot;/g; s/</&lt;/g; s/>/&gt;/g; return $_; }
				, 'checked'			=> sub { $defonly ? 'checked="checked"' : "" }
				, 'defs'			=> \&defsexpand
				, 'uses'			=> \&usesexpand
				)
			)
	);
}

httpinit;
makeheader('ident');
$defonly = 1 if	($HTTP->{'param'}{'_identdefonly'}
				||	(  $config->{'identdefonly'}
					&& !exists($HTTP->{'param'}{'_remember'})
					)
				);
printident;
makefooter('ident');
httpclean;

