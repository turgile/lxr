#!/usr/bin/perl -T
# $Id: ident,v 1.34 2012/09/17 11:46:57 ajlittoz Exp $

# ident --	Look up identifiers
#
#	Arne Georg Gleditsch <argggh@ifi.uio.no>
#	Per Kristian Gjermshus <pergj@ifi.uio.no>
#
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

######################################################################

$CVSID = '$Id: ident,v 1.34 2012/09/17 11:46:57 ajlittoz Exp $ ';

use strict;
use lib '.'; # for Local.pm
use lib do { $0 =~ m{(.*)/} ? "$1/lib" : "lib" }; # if LXR modules are in ./lib

use LXR::Common;
use LXR::Template;
use Local;

our $defonly = undef;
my $reference_hits;
my $declare_hits;
my $file_hits;

sub varinputs {
	my $ret = '';
	foreach ($config->allvariables) {
		if ($config->variable($_) ne $config->vardefault($_)) {
			$ret .= "<input type=\"hidden\" name=\"$_\" value=\"" . $config->variable($_) . "\">\n";
		}
	}
	return $ret;
}

sub countfiles {
	my $refs = shift;

	$file_hits = 0;
	my $last_file;
	foreach my $ref (@$refs) {
		my ($file, $line, $type, $rel) = @$ref;
		$file_hits++ if $file ne $last_file;
		$last_file = $file;
	}
}

sub refsexpand {
	my ($templ, $refs) = @_;
	my $ret   = '';
	my $last_file;

	countfiles ($refs);
	if ($templ =~ m/\$lines\b/) {
		my @lines;
		$last_file = @$refs[0];
		($last_file) = @$last_file;
		my $i = 0;
		foreach my $ref (@$refs) {
			my ($file, $line, $type, $rel) = @$ref;
			if ($last_file eq $file) {
				push @lines, $line;
			}
LAST_EXPAND:
			++$i;
			if	( $last_file ne $file
				|| $i >= scalar (@$refs)
				) {
				$ret .= expandtemplate
						( $templ
						,	( 'file'	=>
					sub { fileref("$last_file", "identfile", $last_file) }
							, 'fileonce'=>
					sub { return fileref("$last_file", "identfile", $last_file) }
							, 'lines'	=> sub {
								join	( ' '
										, map { fileref( "$_", "identline", $last_file, $_)
											} @lines
										) }
							, 'type'	=> sub { $type }
							, 'rel'		=>
					sub { return idref("$rel", "identrel", $rel) }
							, 'fileref'	=> sub {
								fileref("$last_file, line $line", "identline", $last_file, $line);
											}
							)
						);
				@lines = ($line);
				if	(	$i == scalar (@$refs)
					&&	$last_file ne $file
					) {
					$last_file = $file;
					goto LAST_EXPAND;
				}
			}
		$last_file = $file;
		}
	} else {
		foreach my $ref (@$refs) {
			my ($file, $line, $type, $rel) = @$ref;
			my $fileonce = $file if $last_file ne $file;
			$ret .= expandtemplate
					( $templ
					,	( 'file'	=>
				sub { fileref("$file", "identfile", $file) }
						, 'fileonce'=>
				sub { if ($fileonce) { return fileref("$fileonce", "identfile", $file) } }
						, 'line'	=>
				sub { return fileref( "$line", "identline", $file, $line) }
						, 'type'	=> sub { $type }
						, 'rel'		=>
				sub { return idref("$rel", "identrel", $rel) }
						, 'fileref'	=> sub {
							fileref("$file, line $line", "search-decl", $file, $line);
										}
						)
					);
			$last_file = $file;
		}
	}
	return $ret;
}

sub defsexpand {
	my $templ = shift;
	my $ret;

	my @defs = $index->symdeclarations($identifier, $releaseid);
	countfiles (\@defs);
	return '' if (scalar(@defs) == 0);

	my $last_file;
	$ret = expandtemplate
			( $templ
			,	( 'refs'	=> sub { refsexpand (@_, \@defs) }
				, 'occurs'	=> sub { scalar(@defs) }
				, 'filehits'=> sub { $file_hits }
				)
			);
	return $ret;
}

sub usesexpand {
	my $templ = shift;
	my $ret   = '';

	return '' if $defonly;
	my @uses = $index->symreferences($identifier, $releaseid);
	countfiles (\@uses);
	return '' if (scalar(@uses) == 0);

	my $last_file;
	$ret = expandtemplate
			( $templ
			,	( 'refs'	=> sub { refsexpand (@_, \@uses) }
				, 'occurs'	=> sub { scalar(@uses) }
				, 'filehits'=> sub { $file_hits }
				)
			);
	return $ret;
}

sub printident {
	my $dir = shift;
	my $templ;
	my $errorsig = "<!-- ! -->";

	$templ = gettemplate	( 'htmlident'
							, $errorsig
							, "<h2 class\"error\">Identifier search not available without 'htmlident' template</h2>\n"
							);
		if ($templ =~ m/^$errorsig/) {
		die "'htmlident' template not configured";
	}

	print(
		expandtemplate
			( $templ
			,	( 'variables'		=> \&varinputs
				, 'identifier'		=> sub { $_ = $identifier; s/</&lt;/g; s/>/&gt;/g; return $_; }
				, 'identifier_escaped'=> sub { $_ = $identifier; s/\"/&quot;/g; s/</&lt;/g; s/>/&gt;/g; return $_; }
				, 'checked'			=> sub { $defonly ? 'checked="checked"' : "" }
				, 'defs'			=> \&defsexpand
				, 'uses'			=> \&usesexpand
				)
			)
	);
}

httpinit;
makeheader('ident');
$defonly = 1 if	($HTTP->{'param'}{'_identdefonly'}
				||	(  $config->{'identdefonly'}
					&& !exists($HTTP->{'param'}{'_remember'})
					)
				);
printident;
makefooter('ident');
httpclean;

