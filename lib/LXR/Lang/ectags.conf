--regex-comment= VB regexps modified from http://www.rutherfurd.net/weblog/2003/04/; the two variable lines are a bad hack to match array variables but not match functions/subs
--langdef=VB
--langmap=VB:.bas.cls.ctl.frm.vbs
--regex-VB=/^[ \t]*(Public|Private|\b)[ \t]*Sub[ \t]+([a-zA-Z0-9_]+)/\2/s,subroutine/i
--regex-VB=/^[ \t]*(Public|Private|\b)[ \t]*Function[ \t]+([a-zA-Z0-9_]+)/\2/f,function/i
--regex-VB=/^[ \t]*(Public|Private|\b)[ \t]*Type[ \t]+([a-zA-Z0-9_]+)/\2/t,type/i
--regex-VB=/([a-zA-Z0-9_]+)[ \t]+As[ \t]+/\1/v,variable/
--regex-VB=/(Public|Private|Global|Dim|ByVal|ByRef|\b)[ \t]*([a-zA-Z0-9_]+)\(.*\)[ \t]+As[ \t]+/\2/v,variable/
--regex-VB=/^[ \t]*(Public|Private|Global|Dim|\b)[ \t]*Const[ \t]+([a-zA-Z0-9_]+)[ \t]+(As|=)[ \t]+/\2/c,const/i
--regex-VB=/^[ \t]*(Public|\b)[ \t]*Property[ \t]*(Get|Let|Set)[ \t]+([a-zA-Z0-9_]+)/\3/n,name/i
--regex-VB=/^[ \t]*(Public|Private|\b)[ \t]*Enum[ \t]+([a-zA-Z0-9_]+)/\2/e,enum/i
--regex-VB=/^([a-zA-Z_]+):/\1/l,label/i

--regex-comment= we define SQL2 with regexps because the built-in SQL parsing doesn't work right; unfortunately this indexes supposed identifiers in comments so we have to make the regexps as restrictive as possible.  Often we get invalid field matches because comments include datatype keywords like 'date', so the field regexp has an ugly hack that you can't have any words between the beginning of a line and the identifier before the datatype
--langdef=SQL2
--langmap=SQL2:.sql
--regex-SQL2=/^[ \t]*CREATE[ \t]+([a-zA-Z0-9 \t]*)?TABLE[ \t]+([^.]+\.)?"?([a-zA-Z0-9_@.]+)/\3/t,table/i
--regex-SQL2=/^[ \t]*CREATE[ \t]+([a-zA-Z0-9 \t]*)?VIEW[ \t]+([^.]+\.)?"?([a-zA-Z0-9_@.]+)/\3/v,view/i
--regex-SQL2=/^[^a-zA-Z0-9_]*([a-zA-Z_][a-zA-Z0-9_]*)[ \t]+(number|varchar|varchar2|bool|boolean|bit|character|char|text|smallint|int|bigint|integer|real|double|float|date|time|timestamp|interval|long|wchar|varwchar|longwvarchar|decimal|numeric|binary|varbinary|guid)([^a-zA-Z0-9_]|$)/\1/f,field/i
--regex-SQL2=/[^a-zA-Z0-9_]CONSTRAINT[ \t]+([a-zA-Z_][a-zA-Z0-9_]*)/\1/c,constraint/i
--regex-SQL2=/^[ \t]*FUNCTION[ \t]+([a-zA-Z_][a-zA-Z0-9_]*)/\1/F,function/i
--regex-SQL2=/^[ \t]*PROCEDURE[ \t]+([a-zA-Z_][a-zA-Z0-9_]*)/\1/P,procedure/i
--regex-SQL2=/^[ \t]*CURSOR[ \t]+([a-zA-Z_][a-zA-Z0-9_]*)/\1/C,cursor/i
--regex-SQL2=/^[ \t]*CREATE[ \t]+([a-zA-Z0-9 \t]*)?INDEX[ \t]+([a-zA-Z_][a-zA-Z0-9_]*)/\2/i,index/i
--regex-SQL2=/^[ \t]*CREATE[ \t]+SEQUENCE[ \t]+([a-zA-Z_][a-zA-Z0-9_]*)/\1/s,sequence/i
--regex-SQL2=/^[ \t]*CREATE[ \t+](OR[ \t]+REPLACE[ \t]+)?TRIGGER[ \t]+([a-zA-Z_][a-zA-Z0-9_]*)/\2/T,trigger/i
--regex-SQL2=/^[ \t]*CREATE[ \t+](OR[ \t]+REPLACE[ \t]+)?PACKAGE[ \t]+(BODY[ \t]+)?([a-zA-Z_][a-zA-Z0-9_]*)/\3/p,package/i

