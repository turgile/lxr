#!/usr/bin/perl -T
# $Id: source,v 1.53 2011/12/21 20:46:33 ajlittoz Exp $

# source --	Present sourcecode as html, complete with references
#  the '/icons' images are available in any standard Apache installation
#
#	Arne Georg Gleditsch <argggh@ifi.uio.no>
#	Per Kristian Gjermshus <pergj@ifi.uio.no>
#
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

######################################################################

$CVSID = '$Id: source,v 1.53 2011/12/21 20:46:33 ajlittoz Exp $ ';

use strict;
use lib '.';    # for Local.pm
use lib do { $0 =~ m{(.*)/} ? "$1/lib" : "lib" };  # if LXR modules are in ./lib

use LXR::Common;
use LXR::Markup;
use LXR::Template;
use Local;

sub diricon {
	my ($templ, $node, $dir) = @_;
	my $img;

	if ($node eq '../') {
		$img = "/icons/back.gif";
	} else {
		if (exists $config->{'iconfolder'}
		&&  exists $config->{'diricon'}
		) {
			$img = $config->{'iconfolder'} . $config->{'diricon'};
		} else {
			$img = "/icons/folder.gif";
		}
	}

	return fileref(
		"<img src=\"$img\" alt=\"folder $node\">",
		"", $dir . $node);
}

sub dirname {
	my ($templ, $node, $dir) = @_;

	if ($node eq '../') {
		return fileref("Parent directory", "dirfolder", $dir . $node);
	} else {
		return fileref($node, "dirfolder", $dir . $node);
	}
}

sub fileicon {
	my ($templ, $node, $dir) = @_;
	my $img;
	my $graphic = $config->graphicfile;
	my $icons = $config->{'icons'};

	if (exists $config->{'iconfolder'}) {
		if ($node =~ m/(\.([^.]+)?)$/) {
			my $ext = $2;

			while (my ($pat, $iconfile) = each %$icons) {
				if ($ext =~ m/^($pat)$/i) {
					$img = $config->{'iconfolder'} . $iconfile;
					keys %$icons;	# reset iterator
					return fileref("<img src=\"$img\">", "", $dir . $node);
				}
			}
			if ($ext =~ m/^($graphic)$/) {
				return fileref("<img src=\""
							. $config->{'iconfolder'}
							. $config->{'graphicicon'}
							. "\">"
							, "", $dir . $node);
			}
		}

		return fileref("<img src=\""
						. $config->{'iconfolder'}
						. $config->{'defaulticon'}
						. "\">"
						, "", $dir . $node);
	}

# Fallback to some generally universally available icons
# in case the above feature is not defined
# but they are usually not appealing.
	if (!defined $img) {
		if ($node =~ /\.[ch]$/) {
			$img = "/icons/c.gif";
		} elsif ($node =~ /\.(cpp|cc|java)$/) {
			$img = "/icons/c.gif";
		} elsif ($node =~ /\.(txt)$/) {
			$img = "/icons/text.gif";
		} elsif ($node =~ /\.(jar|war|ear|zip|tar|gz|tgz|cab)$/) {
			$img = "/icons/compressed.gif";
		} elsif ($node =~ /\.($graphic)$/) {
			$img = "/icons/image2.gif";
		} else {
			$img = "/icons/generic.gif";
		}
	}
	return fileref("<img src=\"$img\">",
		"", $dir . $node);
}

sub filename {
	my ($templ, $node, $dir) = @_;
	return fileref($node, "dirfile", $dir . $node);
}

sub filesize {
	my ($templ, $node, $dir) = @_;

	my $s = $files->getfilesize($dir . $node, $releaseid);
	my $str;

	$str = "$s ";
	if (length($s) > 6) {
		$s >>= 10;
		$str = "${s}ki";
		if (length($s) > 7) {
			$s >>= 10;
			$str = "${s}Mi";
		}
	}
# 	if ($s < 1 << 10) {
# 		$str = "$s";
# 	} else {
# 
# 		#      if ($s < 1<<20) {
# 		$str = ($s >> 10) . "k";
# 
# 		#      } else {
# 		#          $str = ($s>>20) . "M";
# 		#      }
# 	}
	return expandtemplate(
		$templ,
		(
			'bytes'  => sub { return $str },
			'kbytes' => sub { return $str },
			'mbytes' => sub { return $str }
		)
	);
}

sub modtime {
	my ($templ, $node, $dir) = @_;

	my $current_time = time;
	my $file_time    = $files->getfiletime($dir . $node, $releaseid);

	return '-' unless defined($file_time);

	my @t = gmtime($file_time);
	my ($sec, $min, $hour, $mday, $mon, $year) = @t;
	return sprintf(
		"%04d-%02d-%02d %02d:%02d:%02d",
		$year + 1900,
		$mon + 1, $mday, $hour, $min, $sec
	);
}

sub rowclass {
	my ($templ, $line) = @_;
	return ((($line - 1) / 3) % 2) ? "dirrow2" : "dirrow1";
}

sub direxpand {
	my ($templ, $dir) = @_;
	my $direx = '';
	my $line  = 1;
	my %index;
	my @nodes;
	my $node;

	@nodes = $files->getdir($dir, $releaseid);
	unless (@nodes) {
		print(  "<p class=\"error\">\n<i>The directory " . $dir
			  . " does not exist.</i>\n</p>\n");
		if ($files->isa("LXR::Files::CVS")
			and !$HTTP->{'param'}->{'_showattic'})
		{
			print("<p class=\"error\">\n");
			print("<i>This directory might exist in other versions,");
			print	( " try 'Show attic files' or select a different",
					, $config->{'variables'}{'v'}{'name'}
					, ".</i>\n"
					);
			print("</p>\n");
		}

		return;
	}

	unshift(@nodes, '../') unless $dir eq '/';

	#CSS checked _PH_
	foreach $node (@nodes) {
		if ($node =~ /\/$/) {
			$direx .= expandtemplate
				(	$templ
				,	( 'iconlink' => sub { diricon(@_, $node, $dir) }
					, 'namelink' => sub { dirname(@_, $node, $dir) }
					, 'filesize' => sub { '-' }
					, 'modtime'  => sub { modtime(@_, $node, $dir) }
					, 'dirclass' => sub { rowclass(@_, $line++) }
					, 'description' =>
					  sub { descexpand(@_, $node, $dir, $releaseid) }
					)
				);
		} else {
			next if $node =~ /^.*\.[oa]$|^core$|^00-INDEX$/;
			$direx .= expandtemplate
				(	$templ
				,	( 'iconlink'    => sub { fileicon(@_, $node, $dir) }
					, 'namelink'    => sub { filename(@_, $node, $dir) }
					, 'filesize'    => sub { filesize(@_, $node, $dir) }
					, 'modtime'     => sub { modtime(@_,  $node, $dir) }
					, 'dirclass'    => sub { rowclass(@_, $line++) }
					, 'description' => sub {
						( $files->isa('LXR::Files::CVS')
								&& $files->toreal($dir . $node, $releaseid) =~
							  m|/Attic/|
							? "<i>In Attic</i>  "
							: ""
						) . descexpand(@_, $node, $dir, $releaseid);
						}
					)
				);
		}
	}

	return ($direx);
}

sub printdir {
	my $dir = shift;
	my $templ;

	$templ = gettemplate
				( 'htmldir'
				, ""
				, "<ul>\n\$files{\n<li>\$iconlink \$namelink\n}</ul>\n"
				);

	# print the listing itself
	print(expandtemplate
			( $templ
			,	( 'files' => sub { direxpand(@_, $dir) }
				, 'description' => sub { dirdesc($dir, $releaseid) }
				)
			)
	);
}

sub printfile {
	my $raw = shift;

	if ($pathname =~ m|/$|) {
		printdir($pathname);
	} else {
		my $fileh = $files->getfilehandle($pathname, $releaseid);

		if ($fileh) {
			if ($raw) {
				print($fileh->getlines );
			}

			#	    elsif ($node =~ /README$/) {
			#		print("<pre>",
			#		      markupstring($fileh, $node, $index), # FIXME
			#		      "</pre>");
			#	    }
			else {
				if ($config->cvswebprefix) {
					my $revtarget = "";
					$revtarget = "#rev$releaseid" if lc($releaseid) ne "head";
					print "<a href='"
					  . $config->cvswebprefix
					  . $pathname
					  . $config->cvswebpostfix
					  . $revtarget
					  . "'>View CVS Log</a>";
				}
				my @ann = $files->getannotations($pathname, $releaseid);

				if (@ann) {
					my ($a, $b);
					foreach $a (@ann) {
						if ($a eq $b) {
							$a = ' ' x 16;
							next;
						}

						$b = $a;
						$a .=
						  ' ' x (6 - length($a))
						  . $files->getauthor($pathname, $a);
						$a .= ' ' x (16 - length($a));
						if (length($a) > 16) {
							substr($a, 15, 10000, '*');
						}
					}
				}

				my $l;
				my $outfun = sub {
					$l = shift;
					$l =~ s/(\n)/$1.shift(@ann)/ge;
					print $l;
				};
				&$outfun("<pre class=\"filecontent\">\n");
				markupfile($fileh, $outfun);
				&$outfun("</pre>\n");
			}

		}
		else {
			print(
				"<p class=\"error\">\n<i>The file $pathname does not exist.</i>\n</p>\n"
			);
			if ($files->isa("LXR::Files::CVS")
				and !$HTTP->{'param'}->{'_showattic'})
			{
				print("<p class=\"error\">\n");
				print("<i>This directory might exist in other versions,");
				print	( " try 'Show attic files' or select a different",
						, $config->{'variables'}{'v'}{'name'}
						, ".</i>\n"
						);
				print("</p>\n");
			}
		}
	}
}

httpinit;

if ($config->filter && $pathname !~ $config->filter) {
	makeheader('source');
	print("<p class=\"error\">\n<i>The file $pathname does not exist.</i>\n</p>\n");
	makefooter('source');
	exit;
}

# If the file is html then simply pump it out.
if ($pathname =~ /\.(html)$/ || $HTTP->{'param'}->{'_raw'}) {
	printfile(1);
} else {
	my $type = ($pathname !~ m|/$| ? 'source' : 'sourcedir');

	makeheader($type);
	printfile(0);
	makefooter($type);
}

httpclean;
