#!/usr/bin/perl -T
# $Id: search,v 1.43 2012/04/17 08:10:46 ajlittoz Exp $

# search --	Freetext search
#
#	Arne Georg Gleditsch <argggh@ifi.uio.no>
#	Per Kristian Gjermshus <pergj@ifi.uio.no>
#
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

######################################################################

$CVSID = '$Id: search,v 1.43 2012/04/17 08:10:46 ajlittoz Exp $ ';

use strict;
use lib '.'; # for Local.pm
use lib do { $0 =~ m{(.*)/} ? "$1/lib" : "lib" }; # if LXR modules are in ./lib

use LXR::Common;
use LXR::Config;
use LXR::Template;

my $maxhits = 1000;

sub varinputs {
	my $templ = shift;
	my $ret   = '';

	foreach ($config->allvariables) {
		if ($config->variable($_) ne $config->vardefault($_)) {
			$ret .= expandtemplate
						( $templ
						,	( 'variable' => sub { $_ }
							, 'value'    => sub { $config->variable($_) }
							, 'varname'  => sub { $config->vardescription($_) }
							)
						);
		}
	}
	return $ret;
}

sub filename_matches {
	my ($filetext, $advanced, $casesensitive, $file) = @_;
	if ($advanced) {
		if ($casesensitive) {
			if ($file =~ /$filetext/) {
				return 1;
			}
		} elsif ($file =~ /$filetext/i) {
			return 1;
		}
	} else {
		if ($casesensitive) {
			if (index($file, $filetext) != -1) {
				return 1;
			}
		} elsif (index(lc($file), lc($filetext)) != -1) {
			return 1;
		}
	}
	return 0;
}

sub glimpsesearch {
	my ($searchtext, $filetext, $advanced, $casesensitive) = @_;
	my $sourceroot = $config->sourceroot . '/' . $releaseid . '/';

	$ENV{'PATH'} = '/bin:/usr/local/bin:/usr/bin:/usr/sbin';
	$! = '';
	open	( GLIMPSE
			, $config->glimpsebin
		# Don't scan files ending in ,v or ~
				." -F '-v (\\,v\|\\~)\$' "
		# Should we match casesensitive ?
				. ($casesensitive ? "" : "-i")
		# Location of index datadbase
				. " -H "
				.$config->glimpsedir."/".$releaseid
		# The pattern to search for
				." -y -n '$searchtext' 2>&1 |"
			)
	|| print(STDERR "Glimpse subprocess died unexpextedly: $!\n");

	my $numlines     = 0;
	my @glimpselines = ();
	my @glimpsemsgs  = ();
	while (<GLIMPSE>) {
		if (s/^$sourceroot//) {
		my ($file) = $_ =~ /(.*?):\s*/;
	# Keep only occurrences matching file name if given
		next if $filetext and !filename_matches($filetext, $advanced, $casesensitive, $file);
		$numlines++;
		push(@glimpselines, $_);
		if ($numlines >= $maxhits) {
			last;
		} }
		else {
	# Ignore information message
			next if m/^using working-directory/;
	# Strip off eventual command name
			s/^.*?glimpse:\s*//;
			push (@glimpsemsgs, $_);
		}
	}

	close(GLIMPSE);

	my $retval = $? >> 8;

	# The manpage for glimpse says that it returns 2 on syntax errors or
	# inaccessible files. It seems this is not the case.
	# We will have to work around it for the time being.

	if ($retval == 0) {
		my @ret;
		my $i          = 0;
		foreach my $glimpseline (@glimpselines) {
			last if ($i > $maxhits);

			my ($file, $line, $text) = $glimpseline =~ /(.*?):\s*(\d+)\s*:(.*)/;

			$text =~ s/&/&amp;/g;
			$text =~ s/</&lt;/g;
			$text =~ s/>/&gt;/g;

			push @ret, [ $file, $line, $text ];
		} continue {
			$i++;
		}
# Sort the results ascending per file name
		return sort {$$a[0] cmp $$b[0]} @ret;
	} elsif ($retval == 1) {
		my $glimpsebin = $config->glimpsebin;
		my $glimpseresponse = join("<br>", @glimpselines);
		my $glimpseresponse =~ s/$glimpsebin/Reason/;
		my $glimpseresponse =~ s/glimpse: error in searching index//;
		print("<p class='error'>Search failed</p>\n<p>$glimpseresponse</p>\n");
		foreach (@glimpsemsgs) {
			print("<p class='error'>$_</p>\n");
		}
		return;
	} else {
		print("<p class='error'>Unexpected return value $retval from Glimpse (usually means <i>syntax error</i>)</p>\n");
		foreach (@glimpsemsgs) {
			print("<p class='error'>$_</p>\n");
		}
		return;
	}
}

sub swishsearch {
	my ($searchtext, $filetext, $advanced, $casesensitive) = @_;

  my $swishIndex = $config->swishdir . "/" . $releaseid . ".index";
	if (!-e $swishIndex) {
		print "<p class='error'>";
		print "Version '$releaseid' has not been indexed and is unavailable for searching.";
		print "</p>";
		return;
	}
	
	$ENV{'PATH'} = '/bin:/usr/local/bin:/usr/bin:/usr/sbin';
  my $swishCommand =  join(' ', $config->swishbin, "-f", $swishIndex, "-w", "'(" . $searchtext . ")'");
  my $ret = `$swishCommand`;
  my @result = grep { not /^[\#\.]/ } split(/\n/, $ret);

	my $retval = $?;
	my @ret;
	if ($retval == 0) {
		my $numlines = 0;
		foreach my $hit (@result) {
			print $hit, "<br>\n" if $hit =~ /No such file or directory/;	# feeble attempt to print possible errors (e.g. incomplete LD_LIBRARY_PATH causes linking errors)
			next if $hit =~ /^err:/;    # skip; only 'no results' errors happen with return value 0

			my ($score, $file) = $hit =~ /^(\d+) \/(.+) "(.+)" \d+/;
			next if $filetext and !filename_matches($filetext, $advanced, $casesensitive, $file);
			push @ret, [ $file, $score ];
			$numlines++;

			last if ($numlines >= $maxhits);
		}
		return @ret;
	} else {
		print( "<p class='error'>Search failed: internal error</p><br>\n<p>"
				. join("<br>", @result)
				. "<\p>\n");
		return;
	}
}

sub printresults {
	my $templ   = shift;
	my $searchtext = shift;
	my @results = @_;
	my $ret;
	my ($file, $lastfile);

	foreach (@results) {

			# filename, glimpse and swish-e searches provide different data for each result
		if (!ref) {
			$file = $_;
			my $fileonce = $file if $lastfile ne $file;
			$ret .= expandtemplate
				( $templ
				,	( 'text'    => sub { return '' }
					, 'file'    => sub { fileref("$file", "searchfile", "/$file") }
					, 'fileonce'=> sub { if ($fileonce) {
											return fileref("$fileonce", "searchfile", "/$file")
										} else {
											return "&nbsp;"
										}
									}
					, 'line'    => sub { return '' }
					, 'fileref' => sub { fileref("$file", "searchfile", "/$file") }
					, 'tdfile'  => sub { if ($fileonce) {
											return "searchfile"
										} else {
											return "searchfilevoid"
										}
									}
					)
				);
		} elsif ($config->glimpsebin) {
			my (@params) = @$_;
			$file     = $params[0];
			my $fileonce = $file if $lastfile ne $file;
			my $line     = $params[1];
			my $text     = $params[2];
			my $searchtextq = quotemeta ($searchtext);
# May not work always because glimpse pattern are different form Perl's
# but when it works highlights the occurence of searchtext
			$text =~ s!($searchtextq)!<span class="searchtext">$1</span>!g;

			$ret .= expandtemplate
				( $templ
				,	( 'text'    => sub { return "<pre class='searchtext'>$text</pre>" }
					, 'file'    => sub { fileref("$file", "searchfile", "/$file") }
					, 'fileonce'=> sub { if ($fileonce) {
											return fileref("$fileonce", "searchfile", "/$file")
										} else {
											return "&nbsp;"
										}
									}
					, 'line'    => sub { fileref("$line", "searchline", "/$file", "$line") }
					, 'fileref' => sub { fileref("$file, line $line", "searchfile", "/$file", "$line") }
					, 'tdfile'  => sub { if ($fileonce) {
											return "searchfile"
										} else {
											return "searchfilevoid"
										}
									}
					)
				);
		} else {
			my (@params) = @$_;
			$file     = $params[0];
			my $fileonce = $file if $lastfile ne $file;
			my $score    = $params[1];
			$ret .= expandtemplate
				( $templ
				,	( 'text'    => sub { return $score }
					, 'file'    => sub { fileref("$file", "searchfile", "/$file") }
					, 'fileonce'=> sub { if ($fileonce) {
											return fileref("$fileonce", "searchfile", "/$file")
										} else {
											return "&nbsp;"
										}
									}
					, 'line'    => sub { return '' }
					, 'fileref' => sub { fileref("$file", "searchfile", "/$file") }
					, 'tdfile'  => sub { if ($fileonce) {
											return "searchfile"
										} else {
											return "searchfilevoid"
										}
									}
					)
				);
		}
		$lastfile = $file;
	}
	return $ret;
}

sub search {
	my $templ;
	my $errorsig = "<!-- ! -->";

	$templ = gettemplate	( 'htmlsearch'
							, $errorsig
							, "<h2 class\"error\">Free-text search not available without 'htmlsearch' template</h2>\n"
							);
	if ($templ =~ m/^$errorsig/) {
		die "'htmlsearch' template not configured";
	}

	my $searchtext    = $HTTP->{'param'}->{'_string'};
	my $filetext      = $HTTP->{'param'}->{'_filestring'};
	my $advanced      = $HTTP->{'param'}->{'_advanced'};
	my $casesensitive = $HTTP->{'param'}->{'_casesensitive'};

	my @results;
	if ($searchtext ne "") {
		if ($config->glimpsebin) {
			@results = glimpsesearch($searchtext, $filetext, $advanced, $casesensitive);
		} elsif ($config->swishbin and $config->swishdir) {
			@results = swishsearch($searchtext, $filetext, $advanced, $casesensitive);
		} else {
			warning("No freetext search engine configured.");
		}
	} elsif ($filetext ne "") {
		my $FILELISTING;
		if ($config->swishdir and $config->swishbin) {
			unless ($FILELISTING = IO::File->new($config->swishdir . "/$releaseid.filenames")) {
				&warning(
					"Version '$releaseid' has not been indexed and is unavailable for searching<br>Could not open "
					  . $config->swishdir
					  . "/$releaseid.filenames.");
				return;
			}
		} elsif ($config->glimpsedir and $config->glimpsebin) {
			unless ($FILELISTING =
				IO::File->new($config->glimpsedir . "/" . $releaseid . "/.glimpse_filenames"))
			{
				&warning(
					"Version '$releaseid' has not been indexed and is unavailable for searching<br>Could not open "
					  . $config->glimpsedir
					  . "/$releaseid/.glimpse_filenames.");
				return;
			}
		} else {
			warning(
				"Freetext search engine required for file search, and no freetext search engine is configured"
			);
			return;
		}
		my $sourceroot = $config->sourceroot . '/' . $releaseid . '/';
		while (<$FILELISTING>) {
			chomp;
			s/^$sourceroot//;
			push @results, $_ if filename_matches($filetext, $advanced, $casesensitive, $_);
		}
		close($FILELISTING);
	}

	print expandtemplate
		( $templ
		,	( 'variables'          => sub { varinputs( @_) }
			, 'searchtext'         => sub { $_ = $searchtext; s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g; return $_; }
			, 'searchtext_escaped' => sub { $_ = $searchtext; s/\"/&quot;/g; s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g; return $_; }
			, 'filetext_escaped'   => sub { $_ = $filetext; s/\"/&quot;/g; return $_; }
			, 'advancedchecked'      => sub { return $advanced      ? "checked" : "" }
			, 'casesensitivechecked' => sub { return $casesensitive ? "checked" : "" }
			, 'maxhits_message'      => sub {
				return @results == $maxhits
				  ? "<b>Too many hits, displaying first $maxhits</b><br>"
				  : "";
				}

			, 'results'     => sub { printresults(@_, $searchtext, @results) }
			, 'resultcount' => sub { return scalar @results }
			)
		);
}

httpinit;
makeheader('search');
if ($files->isa("LXR::Files::Plain")) {
	&search;
} else {
	print "<h2 class='error'>Free-text search not available with VCSs!</h2>\n";
}
makefooter('search');

httpclean;

