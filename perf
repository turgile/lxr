#!/usr/bin/perl -T
######################################################################
#
# perf --	Dump performance data for this tree
#
#	Andr√© J. Littoz <ajlittoz@users.sourceforge.net>
#
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
######################################################################

use strict;
use lib do { $0 =~ m{(.*)/} ? "$1/lib" : 'lib' };  # if LXR modules are in ./lib

=head1 perf script

This script displays genxref's performance statistics for the various
versions of the tree.

=cut

use LXR::Common;
use LXR::Template;

my $totaltime;
my $inprogress;

=head2 C<duration ($start, $end)>

Function C<duration> returns a human-readable string for the
time difference between its arguments.

=over

=item 1 C<$start>

an I<integer> containing the number of seconds since the epoch for
the beginning of the interval

=item 2 C<$end>

an I<integer> containing the number of seconds since the epoch for
the end of the interval

=back

If the end date is negative, an error occurred during the interval.

If the start date is negative, the step was skipped.

=cut

sub duration {
	my ($start, $end) = @_;
	my ($flag, $seconds, $minutes);

	if (0 > $start) {
	return '<span class=error>skipped</span>'
	}
	if	(	0 == $end
		&&	-2 == $inprogress
		) {
			return '<em>to be done</em>';
	}
	if (0 > $end) {
		$end = -$end;
		$flag = '<span class=error>!</span>&nbsp;';
	}
	$end -= $start;
	if	(0 > $end) {
		return $flag . '<span class=error>crashed</span>'
	}
	$seconds = $end % 60;
	$end = ($end - $seconds) / 60;
	$minutes = $end % 60;
	$end = ($end - $minutes) / 60;
	return $flag . sprintf('%d:%2.2d:%2.2d', $end, $minutes, $seconds);
}


=head2 C<rowclass ($templ, $line)>

Function C<rowclass> is the "$variable" substitution function
for C<lineclass>.
It returns a CSS class name depending on line parity.

=over

=item 1 C<$templ>

a I<string> containing the template (empty for a "variable")

=item 2 C<$line>

an I<integer> containing the line number of the display

=back

=cut

sub rowclass {
	my ($templ, $line) = @_;
	return ((($line - 1) / 3) % 2) ? 'perfrow2' : 'perfrow1';
}


=head2 C<onelineexpand ($temp, $reindex, @versions)>

Function C<onelineexpand> is a "$function" substitution function.
It returns its template expanded for every line matching its
second argument.

=over

=item 1 C<$templ>

a I<string> containing the template

=item 2 C<$reindex>

the full reindex flag as 0 or 1 to select the proper values

=item 3 C<@versions>

an I<array> containing the versions (release-ids) for which
performance data must be edited.

=back

It fetches performance data for the elements of its second argument.

=cut

sub onelineexpand {
	my ($templ, $reindex, @versions) = @_;
	my $direx = '';
	my $line  = 1;
	my $releaseid;
	my @perfdata;

	foreach $releaseid (@versions) {
		@perfdata = $index->getperformance($releaseid, $reindex);
		$totaltime += $perfdata[6] - $perfdata[2];
		$direx .= expandtemplate
			(	$templ
			,	( 'lineclass' => sub { rowclass(@_, $line++) }
				, 'perfversion' => sub { $perfdata[0] }
				, 'perfdate' => sub { _edittime($perfdata[2]) }
				, 'perfpurge' => sub { duration($perfdata[2], $perfdata[3]) }
				, 'preffreetext' => sub { duration($perfdata[3], $perfdata[4]) }
				, 'perfdefn'=> sub { duration($perfdata[4], $perfdata[5]) }
				, 'perfrefs' => sub { duration($perfdata[5], $perfdata[6]) }
				, 'perftotal' => sub { if (0 > $perfdata[6]) {
											'<span class=error>Crashed!</span>'
										} else {
											duration($perfdata[2], $perfdata[6])
										}
									}
				)
			);
	}
	return $direx;
}


=head2 C<perfdataexpand ($templ, $reindex)>

Function C<perfdataexpand> is a "$function" substitution function
for C<perffull>.
It returns its template argument expanded for every line in the DB selection.

=over

=item 1 C<$templ>

a I<string> containing the template

=item 2 C<$reindex>

the full reindex flag as 0 or 1 to select the proper values

=back

It fetches versions involved in purgeing indexations.

The "line" is expanded by a common procedure.

=cut

sub perfdataexpand {
	my ($templ, $reindex) = @_;
	my $direx = '';
	my @versions;
	my $releaseid;
	my @perfdata;

	$index->{'times_versions'} =
		$index->{dbh}->prepare
			( 'select releaseid from '.$config->{'dbprefix'}.'times'
			  . ' where reindex = '.$reindex
			  . ' order by releaseid desc'
			);
	$index->{'times_versions'}->execute();
	while (($releaseid) = $index->{'times_versions'}->fetchrow_array()) {
		push(@versions, $releaseid) unless $releaseid eq ''
	}
	$index->{'times_versions'} = undef;
	$totaltime = 0;
	return onelineexpand($templ, $reindex, @versions);
}


=head2 C<perffpurgeexpand ($templ)>

Function C<perffpurgeexpand> is a "$function" substitution function
for C<perffullpurge>.
It returns its template argument expanded for the line
corresponding to a full purge (column C<releaseid> is a I<null> string).

=over

=item 1 C<$templ>

a I<string> containing the template

=back

It fetches the I<null> version used to store full purge timing.

The "line" is expanded by a common procedure.

=cut

sub perffpurgeexpand {
	my ($templ) = @_;
	my $direx = '';
	my @versions;
	my $releaseid;
	my @perfdata;

	$index->{'times_versions'} =
		$index->{dbh}->prepare
			( 'select releaseid from '.$config->{'dbprefix'}.'times'
			  . ' where releaseid = \'\' and reindex = 1'
			);
	$index->{'times_versions'}->execute();
	if (($releaseid) = $index->{'times_versions'}->fetchrow_array()) {
		push(@versions, $releaseid)
	}
	$index->{'times_versions'} = undef;
	$totaltime = 0;
	return onelineexpand($templ, 1, @versions);
}


=head2 C<gettotaltime ()>

Auxiliary function C<gettotaltime> returns the total elapsed time
over all version indexations (as the sum of individual total
elapsed times).

Due to I<Perl> binding rules for variables (at time of
C<sub> definition), global variable C<$totaltime> cannot be
simply referenced in the calling argument list of function
for C<perftotal> because it would capture the value at
definition time, namely 0.

By using a function, we insure we always get the current
value at time of call.

=cut

sub gettotaltime {
	return $totaltime;
}


=head2 Script entry point

Selects the correct header and footer, retrieves the C<'htmlperf'> template
and launches template expansion.

The script does not use any query argument, however they are managed as usual
which allows to switch to other scripts with variables set as desired.

=cut

my $templ;
my $errorsig = "<!-- ! -->";

httpinit();
($inprogress) = indexstate();
if (-2 == $inprogress) {
	print 'Cache-Control: no-cache', "\n";	# special header for "monitoring" perf
}
std_http_headers();
makeheader(-2 == $inprogress ? 'perfrefresh' : 'perf');
$templ = gettemplate	( 'htmlperf'
						, $errorsig
						, ''
						);
if ($templ =~ m/^$errorsig/) {
	die "Performance dump not available without 'htmlident' template\n";
}
$totaltime = 0;
print(expandtemplate
		( $templ
		,	( 'perffull' => sub { perfdataexpand(@_, 1) }
			, 'perfinc' => sub { perfdataexpand(@_, 0) }
			, 'perffullpurge' => sub { perffpurgeexpand(@_) }
			, 'perftotal'=> sub { duration(0, gettotaltime()) }
			)
		)
);
makefooter('perf');
httpclean;
